import random
import string
import os
import getpass
import sys
from typing import List, Tuple, Dict, Any

# GLOBAL CONSTANTS
SHIFT_VAL = 7
PLAYERS_FILE = "players.txt"
HIGHSCORES_FILE = "highscores.txt"
COLORS = ["R", "G", "B", "Y", "W", "O"]
CODE_LENGTH = 4
MAX_ATTEMPTS = 10


# --- NEW/MODIFIED FUNCTION ---
def generate_random_username(length: int = 6) -> str:
    """
    Generates a random username consisting of 3 lowercase letters and 3 digits.
    The length parameter is ignored to match the source logic (3 letters + 3 digits = 6 chars).
    """
    # Generate 3 random lowercase letters
    letters = ''.join(random.choices(string.ascii_lowercase, k=3))
    # Generate 3 random digits
    numbers = ''.join(random.choices(string.digits, k=3))
    # Concatenate and return the result
    return letters + numbers


# --------------------


def caesar_encrypt(password: str, shift: int = SHIFT_VAL) -> str:
    """
    Implements a Caesar cipher for letters (A-Z, a-z) and digits (0-9).
    """
    enc = []
    for ch in password:
        if ch.isalpha():
            base = ord("A") if ch.isupper() else ord("a")
            rotated = chr((ord(ch) - base + shift) % 26 + base)
            enc.append(rotated)
        elif ch.isdigit():
            rotated = chr((ord(ch) - ord("0") + shift) % 10 + ord("0"))
            enc.append(rotated)
        else:
            enc.append(ch)
    return "".join(enc)


def check_username_exists(username: str) -> bool:
    """
    Checks if a username exists in the players file.
    """
    try:
        with open(PLAYERS_FILE, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    user, _ = line.split(",", 1)
                except ValueError:
                    # malformed line, skip
                    continue
                if user == username:
                    return True
        return False
    except FileNotFoundError:
        return False
    except IOError:
        return False


def register_user() -> None:
    """
    Handles user registration, encrypts password, and saves to file.
    Includes suggesting a random username.
    """
    print("\n=== User Registration ===")
    random_user = generate_random_username()
    print(f"Suggestion: Use '{random_user}'")  # Suggesting random username

    while True:
        username = input("Enter your username: ").strip().lower()
        if username == "":
            print("Username cannot be empty.")
            continue
        if check_username_exists(username):
            print("Username already taken.")
            continue

        try:
            # Password input is hidden by default using getpass
            pw = getpass.getpass("Enter your password (hidden): ")
        except (KeyboardInterrupt, EOFError):
            print("\nRegistration cancelled.")
            return

        if pw == "":
            print("Password cannot be empty.")
            continue

        enc_pw = caesar_encrypt(pw)

        try:
            # Ensures directory exists (only necessary if PLAYERS_FILE includes a directory path)
            os.makedirs(os.path.dirname(PLAYERS_FILE) or ".", exist_ok=True)
            with open(PLAYERS_FILE, "a", encoding="utf-8") as f:
                f.write(f"{username},{enc_pw}\n")
            print("Registration successful.")
            return
        except IOError as e:
            print(f"Error writing to database: {e}")
            return


def login_user() -> Tuple[bool, str]:
    """
    Handles user login and password verification.
    Return (success, username). On success username is the logged-in username (lowercase).
    """
    print("\n=== User Login ===")
    while True:
        try:
            username = input("Username: ").strip().lower()
        except (KeyboardInterrupt, EOFError):
            print("\nLogin cancelled.")
            return False, ""

        try:
            # Password input is hidden by default using getpass
            pw = getpass.getpass("Password (hidden): ")
        except (KeyboardInterrupt, EOFError):
            print("\nLogin cancelled.")
            return False, ""

        user_found = False
        login_successful = False
        try:
            with open(PLAYERS_FILE, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        user, stored_enc_pw = line.split(",", 1)
                    except ValueError:
                        continue

                    if user == username:
                        user_found = True
                        if caesar_encrypt(pw) == stored_enc_pw:
                            print("Login successful.")
                            login_successful = True
                        else:
                            print("Access Denied")
                        break

        except FileNotFoundError:
            print("Database file not found. Please register first.")
            return False, ""
        except IOError as e:
            print(f"Error reading database: {e}")
            return False, ""

        if login_successful:
            return True, username

        if not user_found:
            try_again = input("Username not found. Do you want to try again? (Y/N): ").strip().upper()
            if try_again != "Y":
                return False, ""
        else:
            # user found but wrong password
            try_again = input("Try again? (Y/N): ").strip().upper()
            if try_again != "Y":
                return False, ""


def generate_secret_code() -> List[str]:
    """
    Generates a random secret code of length CODE_LENGTH using COLORS.
    """
    return [random.choice(COLORS) for _ in range(CODE_LENGTH)]


def parse_guess(raw: str) -> List[str] or None:
    """
    Parses a raw input string into a valid list of colors for the guess.

    Accepts:
      - 4-letter string like "RGBY"
      - space/comma-separated like "R G B Y" or "R,G,B,Y"
    Returns list of uppercase letters or None if invalid.
    """
    raw = raw.strip().upper()
    if not raw:
        return None

    # allow commas or spaces
    for sep in [",", " "]:
        if sep in raw:
            # Use ' ' as a uniform separator after replacing commas
            parts = [p for p in (raw.replace(",", " ").split()) if p]

            if len(parts) != CODE_LENGTH:
                return None

            # accept "Red" as "R" if user typed words by taking the first char
            parts = [p[0] for p in parts]

            if all(p in COLORS for p in parts):
                return parts
            return None

    # no separator -> maybe contiguous letters "RGBY"
    if len(raw) == CODE_LENGTH and all(ch in COLORS for ch in raw):
        return list(raw)

    return None


def score_guess(secret: List[str], guess: List[str]) -> Tuple[int, int]:
    """
    Compares the guess against the secret code and returns black and white pegs.
    """
    # black = correct color and position
    black = sum(1 for s, g in zip(secret, guess) if s == g)

    # count colors ignoring black positions
    secret_counts = {}
    guess_counts = {}

    for i in range(len(secret)):
        if secret[i] != guess[i]:
            secret_counts[secret[i]] = secret_counts.get(secret[i], 0) + 1
            guess_counts[guess[i]] = guess_counts.get(guess[i], 0) + 1

    # white is sum of min counts for each color
    white = 0
    for color, cnt in guess_counts.items():
        white += min(cnt, secret_counts.get(color, 0))

    return black, white


def play_game(username: str) -> Tuple[int, bool]:
    """
    Executes one round of the Mastermind game. Returns attempts used and win status.
    """
    secret = generate_secret_code()
    # print("DEBUG secret:", "".join(secret)) # Uncomment for debugging

    print("\n=== Mastermind: Guess the 4-color code ===")
    print(f"Colors: {', '.join(COLORS)} (use letters). Code length: {CODE_LENGTH}.")
    print(f"You have {MAX_ATTEMPTS} attempts. Repeats allowed.")

    attempts_used = 0

    for attempt in range(1, MAX_ATTEMPTS + 1):
        attempts_used = attempt
        while True:
            raw = input(f"Attempt {attempt}/{MAX_ATTEMPTS} - Enter your guess: ")
            guess = parse_guess(raw)
            if guess is None:
                print(f"Invalid guess. Enter {CODE_LENGTH} colors using letters from {COLORS}.")
                continue
            break

        black, white = score_guess(secret, guess)
        print(f"Feedback -> Black pegs (correct color+pos): {black}, White pegs (correct color wrong pos): {white}")

        if black == CODE_LENGTH:
            print("You Win! ðŸŽ‰")
            return attempts_used, True

    # out of attempts
    print("Game Over! Code was: " + "".join(secret))
    return attempts_used, False


def load_highscores() -> Dict[str, int]:
    """
    Loads highscores from HIGHSCORES_FILE into a dictionary.
    """
    scores = {}
    try:
        with open(HIGHSCORES_FILE, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    user, s = line.split(",", 1)
                    scores[user] = int(s)
                except ValueError:
                    continue
    except FileNotFoundError:
        pass
    except IOError:
        pass
    return scores


def save_highscores(scores: Dict[str, int]) -> None:
    """
    Saves the highscores dictionary to HIGHSCORES_FILE.
    """
    try:
        with open(HIGHSCORES_FILE, "w", encoding="utf-8") as f:
            for user, s in scores.items():
                f.write(f"{user},{s}\n")
    except IOError as e:
        print(f"Error writing highscores: {e}")


def update_leaderboard(username: str, score: int) -> None:
    """
    Updates the user's highscore if the new score is lower (better).
    """
    scores = load_highscores()
    prev = scores.get(username)

    # lower score is better (fewer attempts)
    if prev is None or score < prev:
        scores[username] = score
        save_highscores(scores)
        if prev is None:
            print(f"New highscore added for {username}: {score}")
        else:
            print(f"Highscore improved for {username}: {prev} -> {score}")
    else:
        print(f"No leaderboard update: {username}'s best is {prev}, your score was {score}")


def display_top5() -> None:
    """
    Loads and displays the top 5 highscores.
    """
    scores = load_highscores()
    if not scores:
        print("No highscores yet.")
        return

    # sort by score ascending (lower score is better), then by username
    sorted_scores = sorted(scores.items(), key=lambda kv: (kv[1], kv[0]))

    print("\n=== Top 5 Players ===")
    for i, (user, s) in enumerate(sorted_scores[:5], start=1):
        print(f"{i}. {user} - {s}")
    print("=====================")


def main_menu() -> None:
    """
    Displays the main menu and handles user choices.
    """
    while True:
        print("\nMain Menu")
        print("[R] Register")
        print("[L] Login & Play")
        print("[E] Exit")
        choice = input("Your choice: ").strip().upper()

        if choice == "R":
            register_user()
        elif choice == "L":
            success, username = login_user()
            if success:
                attempts, won = play_game(username)
                score = attempts  # Lower score (fewer guesses) is better
                update_leaderboard(username, score)
                display_top5()
        elif choice == "E":
            print("Exiting application. Goodbye! ðŸ‘‹")
            break
        else:
            print("Invalid choice. Please enter R, L, or E.")


if __name__ == "__main__":
    try:
        main_menu()
    except KeyboardInterrupt:
        print("\nInterrupted. Goodbye! ðŸ‘‹")
        sys.exit(0)
